!SLIDE bullets
# Why Rails?

* _Wait, why are you here?_

!SLIDE bullets incremental
# Why Rails? (cont.)

* Full stack web development
    * DB access
    * Provisions for managing CSS & JS
* Lets you build apps _without_ being a master at...
    * TCP
    * DBs/SQL
    * CSS
    * JS
    * DevOps

.pull-right (cont.)

.notes Startups

!SLIDE bullets incremental
# Why Rails? (cont.)

* It's Ruby! ...Do a lot with little work.
* Conducive to team collaboration.
    * Lets you get right to solving the problem.
    * Accommodates change easily.
* Well-designed and organized.
    * Model-View-Controller.
    * RESTful out of the box.

.pull-right (cont.)

!SLIDE bullets incremental
# Why Rails? (cont.)

* Support.
    * Support for all kinds of DBs.
    * Lots of plugins: write less code!
* Database migrations.
* It's easy...
    * to manage dependencies.
    * to test.
    * to deploy.
* Jobs!

!SLIDE bullets incremental
# Why *NOT* Rails?

* There's a lot to learn besides Ruby.
    * ERB or HAML for HTML
    * SASS for CSS
    * CoffeeScript for JavaScript
    * Rails
    * MVC
    * Testing framework
    * capybara, selenium
    * rake
    * capistrano

!SLIDE smbullets incremental
# Why *NOT* Rails? (cont.)

* Overkill for your project.
* Magic!
* Can be confusing to debug.
* Ruby doesn't sit well with you.
* Lacking performance
    * 99% of the time, this is is lies!

!SLIDE questions title commandline incremental

```
$ puts "questions?"
```

!SLIDE bullets incremental
# Why Ruby?

* _Who here wants to learn Ruby as much as/more than Rails?_
* You can learn a lot about Ruby from learning Rails.

!SLIDE bullets incremental
# Why Ruby?

* ["Why Ruby?"](http://www.codinghorror.com/blog/2013/03/why-ruby.html) by Jeff Atwood
* Let's you get to solving the problem.
* It's consistently object-oriented.
    * _Everything_ is an object!
* Reflection: Lets you learn it by asking it.
* Flexibility...
    * ...can mean readability.
    * Lots of optional syntax.

.pull-right (cont.)

!SLIDE bullets incremental
# Why Ruby? (cont.)

* You have access to it at every level.
* Ecosystem.
    * RubyGems & Bundler.
    * Wonderful documentation & doc tools; self-documenting code.
* Rails?
* Great testing frameworks.
* Lots of DevOps tools written in Ruby.

.pull-right (cont.)

!SLIDE bullets
# Why Ruby? (cont.)

* Lots of VMs
    * MRI ("Matz' Ruby Interpreter", aka "C Ruby")
    * JRuby
    * RubyMotion/MacRuby
    * Rubinius (Ruby written in Ruby)
    * mruby (for embedded devices)
    * IronRuby (.NET)
    * ruby-python
    * etc.

.pull-right (cont.)

!SLIDE bullets incremental
# Sidenote: Software Maintainability

* ["Over 90% of the cost of software development is software maintenance."](http://tynerblain.com/blog/2007/02/28/agile-development-roi-2/)
* [ISO 9126](http://en.wikipedia.org/wiki/ISO/IEC_9126), Quality Characteristics:
    * Analyzability
    * Changeability
    * Stability
    * Testability

.pull-right (cont.)

!SLIDE bullets incremental
# Sidenote: SW Maintainability (cont.)

* How to mitigate?
    * Write less code!
        * [Don't Repeat Yourself](http://en.wikipedia.org/wiki/Don't_repeat_yourself)
          (DRY)
        * [You ain't gonna need it](http://en.wikipedia.org/wiki/You_aren't_gonna_need_it)
          (YAGNI)
    * Write better code!
    * Write tests that live with the code.
    * Write docs that live with the code.
    * Follow [design patterns](http://en.wikipedia.org/wiki/Software_design_pattern).
    * [Red, Green, Refactor](http://www.jamesshore.com/Blog/Red-Green-Refactor.html).
* Ruby is really good for mitigating these things.

!SLIDE
# Why Ruby?

## Ruby lends itself to writing maintainable code.

!SLIDE
# Why *NOT* Ruby?

* It doesn't feel right.
* You can do really dumb things.
* Too much flexibility.
* Performance?
* Not compiled (usually).
* Not pre-installed on most OSes.

!SLIDE questions title commandline incremental

```
$ puts "questions?"
```

!SLIDE
# Object-Oriented Programming

* Is not Procedural Programming.
* Is not Functional Programming.
